
<!DOCTYPE HTML>
<html lang="ja" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Syscalls · Tock</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-theme-api/theme-api.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="Userland.html" />
    
    
    <link rel="prev" href="Startup.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="検索すると入力" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="Overview.html">
            
                <a href="Overview.html">
            
                    
                    Overview
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="Design.html">
            
                <a href="Design.html">
            
                    
                    Design
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="threat_model/">
            
                <a href="threat_model/">
            
                    
                    Threat Model
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="Lifetimes.html">
            
                <a href="Lifetimes.html">
            
                    
                    Lifetimes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="Mutable_References.html">
            
                <a href="Mutable_References.html">
            
                    
                    Mutable References
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="Soundness.html">
            
                <a href="Soundness.html">
            
                    
                    Soundness
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.4" data-path="Compilation.html">
            
                <a href="Compilation.html">
            
                    
                    Compilation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.5" data-path="TockBinaryFormat.html">
            
                <a href="TockBinaryFormat.html">
            
                    
                    Tock Binary Format
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.6" data-path="Memory_Layout.html">
            
                <a href="Memory_Layout.html">
            
                    
                    Memory Layout
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.7" data-path="Memory_Isolation.html">
            
                <a href="Memory_Isolation.html">
            
                    
                    Memory Isolation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.8" data-path="Registers.html">
            
                <a href="Registers.html">
            
                    
                    Registers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.9" data-path="Startup.html">
            
                <a href="Startup.html">
            
                    
                    Startup
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="2.10" data-path="Syscalls.html">
            
                <a href="Syscalls.html">
            
                    
                    Syscalls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.11" data-path="Userland.html">
            
                <a href="Userland.html">
            
                    
                    Userland
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.12" data-path="Networking_Stack.html">
            
                <a href="Networking_Stack.html">
            
                    
                    Networking Stack
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.13" data-path="Configuration.html">
            
                <a href="Configuration.html">
            
                    
                    Configuration
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="syscalls/">
            
                <a href="syscalls/">
            
                    
                    Syscall Interfaces
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="reference/">
            
                <a href="reference/">
            
                    
                    Internal Kernel Interfaces
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="Getting_Started.html">
            
                <a href="Getting_Started.html">
            
                    
                    Getting Started
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2" data-path="Porting.html">
            
                <a href="Porting.html">
            
                    
                    Porting Tock
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.3" data-path="OutOfTree.html">
            
                <a href="OutOfTree.html">
            
                    
                    Out of Tree Boards
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.4" data-path="debugging/README.md">
            
                <span>
            
                    
                    Debugging Help
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.5" >
            
                <span>
            
                    
                    [Style](Style.mdManagement of Tock
            
                </span>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="wg/">
            
                <a href="wg/">
            
                    
                    Working Groups
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.2" data-path="CodeReview.html">
            
                <a href="CodeReview.html">
            
                    
                    Code Review Process
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            GitBookで公開 
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Syscalls</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="syscalls">Syscalls</h1>
<p>This document explains how <a href="https://en.wikipedia.org/wiki/System_call" target="_blank">system
calls</a> work in Tock with regards
to both the kernel and applications. This is a description of the design
considerations behind the current implementation of syscalls, rather than a
tutorial on how to use them in drivers or applications.</p>
<!-- toc -->
<ul>
<li><a href="#overview-of-system-calls-in-tock">Overview of System Calls in Tock</a></li>
<li><a href="#process-state">Process State</a></li>
<li><a href="#startup">Startup</a></li>
<li><a href="#the-system-calls">The System Calls</a><ul>
<li><a href="#0-yield">0: Yield</a><ul>
<li><a href="#arguments">Arguments</a></li>
<li><a href="#return">Return</a></li>
</ul>
</li>
<li><a href="#1-subscribe">1: Subscribe</a><ul>
<li><a href="#arguments-1">Arguments</a></li>
<li><a href="#return-1">Return</a></li>
</ul>
</li>
<li><a href="#2-command">2: Command</a><ul>
<li><a href="#arguments-2">Arguments</a></li>
<li><a href="#return-2">Return</a></li>
</ul>
</li>
<li><a href="#3-allow">3: Allow</a><ul>
<li><a href="#arguments-3">Arguments</a></li>
<li><a href="#return-3">Return</a></li>
</ul>
</li>
<li><a href="#4-memop">4: Memop</a><ul>
<li><a href="#arguments-4">Arguments</a></li>
<li><a href="#return-4">Return</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#the-context-switch">The Context Switch</a><ul>
<li><a href="#context-switch-interface">Context Switch Interface</a></li>
<li><a href="#cortex-m-architecture-details">Cortex-M Architecture Details</a></li>
<li><a href="#risc-v-architecture-details">RISC-V Architecture Details</a></li>
</ul>
</li>
<li><a href="#how-system-calls-connect-to-drivers">How System Calls Connect to Drivers</a></li>
<li><a href="#allocated-driver-numbers">Allocated Driver Numbers</a></li>
</ul>
<!-- tocstop -->
<h2 id="overview-of-system-calls-in-tock">Overview of System Calls in Tock</h2>
<p>System calls are the method used to send information from applications to the
kernel. Rather than directly calling a function in the kernel, applications
trigger a service call (<code>svc</code>) interrupt which causes a context switch to the
kernel. The kernel then uses the values in registers and the stack at the time
of the interrupt call to determine how to route the system call and which
driver function to call with which data values.</p>
<p>Using system calls has three advantages. First, the act of triggering a service
call interrupt can be used to change the processor state. Rather than being in
unprivileged mode (as applications are run) and limited by the Memory
Protection Unit (MPU), after the service call the kernel switches to privileged
mode where it has full control of system resources (more detail on ARM
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0553a/CHDIGFCA.html" target="_blank">processor
modes</a>).
Second, context switching to the kernel allows it to do other resource handling
before returning to the application. This could include running other
applications, servicing queued callbacks, or many other activities. Finally,
and most importantly, using system calls allows applications to be built
independently from the kernel. The entire codebase of the kernel could change,
but as long as the system call interface remains identical, applications do not
even need to be recompiled to work on the platform. Applications, when
separated from the kernel, no longer need to be loaded at the same time as the
kernel. They could be uploaded at a later time, modified, and then have a new
version uploaded, all without modifying the kernel running on a platform.</p>
<h2 id="process-state">Process State</h2>
<p>In Tock, a process can be in one of three states:</p>
<ul>
<li><strong>Running</strong>: Normal operation. A Running process is eligible to be scheduled
for execution, although is subject to being paused by Tock to allow interrupt
handlers or other processes to run. During normal operation, a process remains
in the Running state until it explicitly yields. Callbacks from other kernel
operations are not delivered to Running processes (i.e. callbacks do not
interrupt processes), rather they are enqueued until the process yields.</li>
<li><strong>Yielded</strong>: Suspended operation. A Yielded process will not be scheduled by
Tock. Processes often yield while they are waiting for I/O or other operations
to complete and have no immediately useful work to do. Whenever the kernel issues
a callback to a Yielded process, the process is transitioned to the Running state.</li>
<li><strong>Fault</strong>: Erroneous operation. A Fault-ed process will not be scheduled by
Tock. Processes enter the Fault state by performing an illegal operation, such
as accessing memory outside of their address space.</li>
</ul>
<h2 id="startup">Startup</h2>
<p>Upon process initialization, a single function call task is added to its
callback queue. The function is determined by the ENTRY point in the process
TBF header (typically the <code>_start</code> symbol) and is passed the following
arguments in registers <code>r0</code> - <code>r3</code>:</p>
<ul>
<li>r0: the base address of the process code</li>
<li>r1: the base address of the processes allocated memory region</li>
<li>r2: the total amount of memory in its region</li>
<li>r3: the current process memory break</li>
</ul>
<h2 id="the-system-calls">The System Calls</h2>
<p>All system calls except Yield (which cannot fail) return an integer return code
value to userspace. Negative return codes indicate an error. Values greater
than or equal to zero indicate success. Sometimes syscall return values encode
useful data, for example in the <code>gpio</code> driver, the command for reading the
value of a pin returns 0 or 1 based on the status of the pin.</p>
<p>Currently, the following return codes are defined, also available as <code>#defines</code>
in C from the <code>tock.h</code> header (prepended with <code>TOCK_</code>):</p>
<pre><code class="lang-rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ReturnCode</span></span> {
    SuccessWithValue { value: usize }, <span class="hljs-comment">// Success value must be &gt;= 0</span>
    SUCCESS,
    FAIL, <span class="hljs-comment">//.......... Generic failure condition</span>
    EBUSY, <span class="hljs-comment">//......... Underlying system is busy; retry</span>
    EALREADY, <span class="hljs-comment">//...... The state requested is already set</span>
    EOFF, <span class="hljs-comment">//.......... The component is powered down</span>
    ERESERVE, <span class="hljs-comment">//...... Reservation required before use</span>
    EINVAL, <span class="hljs-comment">//........ An invalid parameter was passed</span>
    ESIZE, <span class="hljs-comment">//......... Parameter passed was too large</span>
    ECANCEL, <span class="hljs-comment">//....... Operation cancelled by a call</span>
    ENOMEM, <span class="hljs-comment">//........ Memory required not available</span>
    ENOSUPPORT, <span class="hljs-comment">//.... Operation or command is unsupported</span>
    ENODEVICE, <span class="hljs-comment">//..... Device does not exist</span>
    EUNINSTALLED, <span class="hljs-comment">//.. Device is not physically installed</span>
    ENOACK, <span class="hljs-comment">//........ Packet transmission not acknowledged</span>
}
</code></pre>
<h3 id="0-yield">0: Yield</h3>
<p>Yield transitions the current process from the Running to the Yielded state, and
the process will not execute again until another callback re-schedules the
process.</p>
<p>If a process has enqueued callbacks waiting to execute when Yield is called, the
process immediately re-enters the Running state and the first callback runs, unless
the scheduler chooses to prioritize some other operation first.</p>
<pre><code class="lang-rust"><span class="hljs-keyword">yield</span>()
</code></pre>
<h4 id="arguments">Arguments</h4>
<p>None.</p>
<h4 id="return">Return</h4>
<p>None.</p>
<h3 id="1-subscribe">1: Subscribe</h3>
<p>Subscribe assigns callback functions to be executed in response to various
events.</p>
<p>A callback function is uniquely identified by the pair (<code>driver</code>,
<code>subscribe_number</code>), a.k.a. <em>callback ID</em>. When calling <code>subscribe</code>, if there
are any pending callbacks for this callback ID, they are removed from the queue
before the new callback function is bound to the callback ID.</p>
<p>A process can pass a null pointer as the callback argument to request the driver
disable a previously set callback (besides flushing pending callbacks for this
callback ID).</p>
<pre><code class="lang-rust">subscribe(driver: <span class="hljs-keyword">u32</span>, subscribe_number: <span class="hljs-keyword">u32</span>, callback: <span class="hljs-keyword">u32</span>, userdata: <span class="hljs-keyword">u32</span>) -&gt; ReturnCode <span class="hljs-keyword">as</span> <span class="hljs-keyword">u32</span>
</code></pre>
<h4 id="arguments">Arguments</h4>
<ul>
<li><code>driver</code>: An integer specifying which driver to call.</li>
<li><code>subscribe_number</code>: An integer index for which function is being subscribed.</li>
<li><code>callback</code>: A pointer to a callback function to be executed when this event
occurs. All callbacks conform to the C-style function signature:
<code>void callback(int arg1, int arg2, int arg3, void* data)</code>.</li>
<li><code>userdata</code>: A pointer to a value of any type that will be passed back by the
kernel as the last argument to <code>callback</code>.</li>
</ul>
<p>Individual drivers define a mapping for <code>subscribe_number</code> to the events that
may generate that callback as well as the meaning for each of the <code>callback</code>
arguments.</p>
<h4 id="return">Return</h4>
<ul>
<li><code>ENODEVICE</code> if <code>driver</code> does not refer to a valid kernel driver.</li>
<li><code>ENOSUPPORT</code> if the driver exists but doesn&apos;t support the <code>subscribe_number</code>.</li>
<li>Other return codes based on the specific driver.</li>
</ul>
<h3 id="2-command">2: Command</h3>
<p>Command instructs the driver to perform a specific action.</p>
<pre><code class="lang-rust">command(driver: <span class="hljs-keyword">u32</span>, command_number: <span class="hljs-keyword">u32</span>, argument1: <span class="hljs-keyword">u32</span>, argument2: <span class="hljs-keyword">u32</span>) -&gt; ReturnCode <span class="hljs-keyword">as</span> <span class="hljs-keyword">u32</span>
</code></pre>
<h4 id="arguments">Arguments</h4>
<ul>
<li><code>driver</code>: An integer specifying which driver to call.</li>
<li><code>command_number</code>: An integer specifying the requested command.</li>
<li><code>argument1</code>: A command-specific argument.</li>
<li><code>argument2</code>: A command-specific argument.</li>
</ul>
<p>The <code>command_number</code> tells the driver which command was called from
userspace, and the <code>argument</code>s are specific to the driver and command number.
One example of the argument being used is in the <code>led</code> driver, where the
command to turn on an LED uses the argument to specify which LED.</p>
<p>One Tock convention with the Command syscall is that command number 0 will
always return a value of 0 or greater if the driver is supported by the running
kernel. This means that any application can call command number 0 on any driver
number to determine if the driver is present and the related functionality is
supported. In most cases this command number will return 0, indicating that the
driver is present. In other cases, however, the return value can have an
additional meaning such as the number of devices present, as is the case in the
<code>led</code> driver to indicate how many LEDs are present on the board.</p>
<h4 id="return">Return</h4>
<ul>
<li><code>ENODEVICE</code> if <code>driver</code> does not refer to a valid kernel driver.</li>
<li><code>ENOSUPPORT</code> if the driver exists but doesn&apos;t support the <code>command_number</code>.</li>
<li>Other return codes based on the specific driver.</li>
</ul>
<h3 id="3-allow">3: Allow</h3>
<p>Allow marks a region of memory as shared between the kernel and application.
Passing a null pointer requests the corresponding driver to stop accessing the
shared memory region.</p>
<pre><code class="lang-rust">allow(driver: <span class="hljs-keyword">u32</span>, allow_number: <span class="hljs-keyword">u32</span>, pointer: usize, size: <span class="hljs-keyword">u32</span>) -&gt; ReturnCode <span class="hljs-keyword">as</span> <span class="hljs-keyword">u32</span>
</code></pre>
<h4 id="arguments">Arguments</h4>
<ul>
<li><code>driver</code>: An integer specifying which driver should be granted access.</li>
<li><code>allow_number</code>: A driver-specific integer specifying the purpose of this
buffer.</li>
<li><code>pointer</code>: A pointer to the start of the buffer in the process memory space.</li>
<li><code>size</code>: An integer number of bytes specifying the length of the buffer.</li>
</ul>
<p>Many driver commands require that buffers are Allow-ed before they can execute.
A buffer that has been Allow-ed does not need to be Allow-ed to be used again.</p>
<p>As of this writing, most Tock drivers do not provide multiple virtual devices to
each application. If one application needs multiple users of a driver (i.e. two
libraries on top of I2C), each library will need to re-Allow its buffers before
beginning operations.</p>
<h4 id="return">Return</h4>
<ul>
<li><code>ENODEVICE</code> if <code>driver</code> does not refer to a valid kernel driver.</li>
<li><code>ENOSUPPORT</code> if the driver exists but doesn&apos;t support the <code>allow_number</code>.</li>
<li><code>EINVAL</code> the buffer referred to by <code>pointer</code> and <code>size</code> lies completely or
partially outside of the processes addressable RAM.</li>
<li>Other return codes based on the specific driver.</li>
</ul>
<h3 id="4-memop">4: Memop</h3>
<p>Memop expands the memory segment available to the process, allows the process to
retrieve pointers to its allocated memory space, provides a mechanism for
the process to tell the kernel where its stack and heap start, and other
operations involving process memory.</p>
<pre><code class="lang-rust">memop(op_type: <span class="hljs-keyword">u32</span>, argument: <span class="hljs-keyword">u32</span>) -&gt; [[ VARIES ]] <span class="hljs-keyword">as</span> <span class="hljs-keyword">u32</span>
</code></pre>
<h4 id="arguments">Arguments</h4>
<ul>
<li><code>op_type</code>: An integer indicating whether this is a <code>brk</code> (0), a <code>sbrk</code> (1),
or another memop call.</li>
<li><code>argument</code>: The argument to <code>brk</code>, <code>sbrk</code>, or other call.</li>
</ul>
<p>Each memop operation is specific and details of each call can be found in
the <a href="syscalls/memop.md">memop syscall documentation</a>.</p>
<h4 id="return">Return</h4>
<ul>
<li>Dependent on the particular memop call.</li>
</ul>
<h2 id="the-context-switch">The Context Switch</h2>
<p>Handling a context switch is one of the few pieces of Tock code that is
actually architecture dependent and not just chip-specific. The code is located
in <code>lib.rs</code> within the <code>arch/</code> folder under the appropriate architecture. As
this code deals with low-level functionality in the processor it is written in
assembly wrapped as Rust function calls.</p>
<h3 id="context-switch-interface">Context Switch Interface</h3>
<p>The architecture crates (in the <code>/arch</code> folder) are responsible for implementing
the <code>UserspaceKernelBoundary</code> trait which defines the functions needed to allow the
kernel to correctly switch to userspace. These functions handle the
architecture-specific details of how the context switch occurs, such as which
registers are saved on the stack, where the stack pointer is stored, and how
data is passed for the Tock syscall interface.</p>
<h3 id="cortex-m-architecture-details">Cortex-M Architecture Details</h3>
<p>Starting in the kernel before any application has been run but after the
process has been created, the kernel calls <code>switch_to_user</code>. This code sets up
registers for the application, including the PIC base register and the process
stack pointer, then triggers a service call interrupt with a call to <code>svc</code>.
The <code>svc</code> handler code automatically determines if the system desired a switch
to application or to kernel and sets the processor mode. Finally, the <code>svc</code>
handler returns, directing the PC to the entry point of the app.</p>
<p>The application runs in unprivileged mode while executing. When it needs to use
a kernel resource it issues a syscall by running <code>svc</code> instruction. The
<code>svc_handler</code> determines that it should switch to the kernel from an app, sets
the processor mode to privileged, and returns. Since the stack has changed to
the kernel&apos;s stack pointer (rather than the process stack pointer), execution
returns to <code>switch_to_user</code> immediately after the <code>svc</code> that led to the
application starting. <code>switch_to_user</code> saves registers and returns to the kernel
so the system call can be processed.</p>
<p>On the next <code>switch_to_user</code> call, the application will resume execution based
on the process stack pointer, which points to the instruction after the system
call that switched execution to the kernel.</p>
<p>Syscalls may clobber userspace memory, as the kernel may write to buffers
previously given to it using Allow. The kernel will not clobber any userspace
registers except for the return value register (<code>r0</code>). However, Yield must be
treated as clobbering more registers, as it can call a callback in userspace
before returning. This callback can clobber r0-r3, r12, and lr. See <a href="https://github.com/tock/libtock-c/blob/f5004277ec88c2afe8f473a06b74aa2faba70d68/libtock/tock.c#L49" target="_blank">this
comment</a>
in the libtock-c syscall code for more information about Yield.</p>
<h3 id="risc-v-architecture-details">RISC-V Architecture Details</h3>
<p>Tock assumes that a RISC-V platform that supports context switching has two
privilege modes: machine mode and user mode.</p>
<p>The RISC-V architecture provides very lean support for context switching,
providing significant flexibility in software on how to support context
switches. The hardware guarantees the following will happen during a context
switch: when switching from kernel mode to user mode by calling the <code>mret</code>
instruction, the PC is set to the value in the <code>mepc</code> CSR, and the privilege
mode is set to the value in the <code>MPP</code> bits of the <code>mstatus</code> CSR. When switching
from user mode to kernel mode using the <code>ecall</code> instruction, the PC of the
<code>ecall</code> instruction is saved to the <code>mepc</code> CSR, the correct bits are set in the
<code>mcause</code> CSR, and the privilege mode is restored to machine mode. The kernel can
store 32 bits of state in the <code>mscratch</code> CSR.</p>
<p>Tock handles context switching using the following process. When switching to
userland, all register contents are saved to the kernel&apos;s stack. Additionally, a
pointer to a per-process struct of stored process state and the PC of where in
the kernel to resume executing after the app switches back to kernel mode are
stored to the kernel&apos;s stack. Then, the PC of the app to start executing is put
into the <code>mepc</code> CSR, the kernel stack pointer is saved in <code>mscratch</code>, and the
previous contents of the app&apos;s registers from the per-process stored state
struct are copied back into the registers. Then <code>mret</code> is called to switch to
user mode and begin executing the app.</p>
<p>When the app calls a syscall, it uses the <code>ecall</code> instruction. This causes the
trap handler to execute. The trap handler checks <code>mscratch</code>, and if the value is
nonzero then it contains the stack pointer of the kernel and this trap must have
happened while the system was executing an application. Then, the kernel stack
pointer from <code>mscratch</code> is used to find the pointer to the stored state struct,
and all app registers are saved. The trap handler also saves the app PC from the
<code>mepc</code> CSR and the <code>mcause</code> CSR. It then loads the kernel address of where to
resume the context switching code to <code>mepc</code> and calls <code>mret</code> to exit the trap
handler. Back in the context switching code, the kernel restores its registers
from its stack. Then, using the contents of <code>mcause</code> the kernel decides why the
application stopped executing, and if it was a syscall which syscall the app
called. Returning the context switch reason ends the context switching process.</p>
<p>All values for the syscall functions are passed in registers <code>a0-a4</code>. No values
are stored to the application stack. The return value for syscalls is set in a0.
In most syscalls the kernel will not clobber any userspace registers except for
this return value register (<code>a0</code>). However, the <code>yield()</code> syscall results in a
callback getting run in the app. This can clobber all caller saved registers, as
well as the return address (<code>ra</code>) register.</p>
<h2 id="how-system-calls-connect-to-drivers">How System Calls Connect to Drivers</h2>
<p>After a system call is made, the call is handled and routed by the Tock kernel
in <a href="../kernel/src/sched.rs"><code>sched.rs</code></a> through a series of steps.</p>
<ol>
<li><p>The kernel calls a platform-provided syscall filter function to determine if
it should process the syscall or not. This does not apply to <code>yield</code>. The
filter function takes the syscall and which process issued the syscall to
return a <code>Result((), ReturnCode)</code> to signal if the syscall should be handled
or if an error should be returned to the process.</p>
<p>If the filter function disallows the syscall it returns <code>Err(ReturnCode)</code> and
the <code>ReturnCode</code> is provided to the app as the return code for the syscall.
Otherwise, the syscall proceeds.</p>
<p><em>The filter interface is currently considered unstable and subject to change.</em></p>
</li>
<li><p>The number of the syscall is matched against the valid syscall types. <code>yield</code>
and <code>memop</code> have special functionality that is handled by the kernel.
<code>command</code>, <code>subscribe</code>, and <code>allow</code> are routed to drivers for handling.</p>
</li>
<li><p>To route the <code>command</code>, <code>subscribe</code>, and <code>allow</code> syscalls, each board creates
a struct that implements the <code>Platform</code> trait. Implementing that trait only
requires implementing a <code>with_driver()</code> function that takes one argument, the
driver number, and returns a reference to the correct driver if it is
supported or <code>None</code> otherwise. The kernel then calls the appropriate syscall
function on that driver with the remaining syscall arguments.</p>
<p>An example board that implements the <code>Platform</code> trait looks something like
this:</p>
<pre><code class="lang-rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TestBoard</span></span> {
    console: &amp;<span class="hljs-symbol">&apos;static</span> Console&lt;<span class="hljs-symbol">&apos;static</span>, usart::USART&gt;,
}

<span class="hljs-keyword">impl</span> Platform <span class="hljs-keyword">for</span> TestBoard {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">with_driver</span></span>&lt;F, R&gt;(&amp;<span class="hljs-keyword">self</span>, driver_num: usize, f: F) -&gt; R
        <span class="hljs-keyword">where</span> F: <span class="hljs-built_in">FnOnce</span>(<span class="hljs-built_in">Option</span>&lt;&amp;kernel::Driver&gt;) -&gt; R
    {

        <span class="hljs-keyword">match</span> driver_num {
            <span class="hljs-number">0</span> =&gt; f(<span class="hljs-literal">Some</span>(<span class="hljs-keyword">self</span>.console)), <span class="hljs-comment">// use capsules::console::DRIVER_NUM rather than 0 in real code</span>
            _ =&gt; f(<span class="hljs-literal">None</span>),
        }
    }
}
</code></pre>
<p><code>TestBoard</code> then supports one driver, the UART console, and maps it to driver
number 0. Any <code>command</code>, <code>subscribe</code>, and <code>allow</code> sycalls to driver number 0
will get routed to the console, and all other driver numbers will return
<code>ReturnCode::ENODEVICE</code>.</p>
</li>
</ol>
<h2 id="allocated-driver-numbers">Allocated Driver Numbers</h2>
<p>All documented drivers are in the <a href="syscalls/">doc/syscalls</a> folder.</p>
<p>The <code>with_driver()</code> function takes an argument <code>driver_num</code> to identify the
driver. <code>driver_num</code> whose highest bit is set is private and can be used by
out-of-tree drivers.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            

        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Syscalls","level":"2.10","depth":1,"next":{"title":"Userland","level":"2.11","depth":1,"path":"Userland.md","ref":"Userland.md","articles":[]},"previous":{"title":"Startup","level":"2.9","depth":1,"path":"Startup.md","ref":"Startup.md","articles":[]},"dir":"ltr"},"config":{"plugins":["theme-api","livereload"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"livereload":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-api":{"languages":[],"split":true,"theme":"light"},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Tock","language":"ja","gitbook":"*","description":"Tockドキュメント"},"file":{"path":"Syscalls.md","mtime":"2020-09-14T07:33:27.030Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-09-27T01:49:05.493Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-theme-api/theme-api.js"></script>
        
    

    </body>
</html>

